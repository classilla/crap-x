# CRAP-X: CAP-X/COMP-X Resurrected as an Esoteric Programming Language

[Another Old VCR Sin Against Basic Decency!](https://oldvcr.blogspot.com/2024/02/cap-x-and-comp-x-how-tandy-pocket.html)

Copyright 2024 Cameron Kaiser.  
All rights reserved.  
BSD license.

## or: Who Simulates the Simulators?
## or: Who Put This Crap in my Pocket Computer?

CAP-X/COMP-X was a simulated virtual machine developed by the Japanese
then-Ministry of International Trade and Industry (MITI) in 1969 for the
Information Technology Engineer Examination; it later became mandatory knowledge
as part
of the Class I exam in 1977. It presents a hypothetical 16-bit CPU with a
strongly page-based memory model and a very limited instruction set (COMP-X)
using a specific assembler format (CAP-X).
Although only intended as a means of skill assessment and never used as
the native architecture of any known machine, it was implemented in
software on the Oki Electronic OKITAC-4300b in 1980 and then by Casio and
Sharp in various pocket computers from 1985, notably the Sharp PC-1440 and
PC-1416G, and the Casio FX-770P family.

The CAP-X/COMP-X Casios are best known in the West through their Radio Shack
rebadges as the Tandy Pocket Scientific Computer PC-5 (Casio FX-780P) and the
Tandy Pocket Scientific Computer PC-6 (Casio FX-790P). CAP-X/COMP-X was used
as their "Assembler" mode, despite it not being their native architecture
either, nor
did the ultimate provenance of the assembler mode appear anywhere in the
English manual. CAP-X/COMP-X were ultimately superseded by CASL/COMET in
1986, an updated form of the architecture. [Read more about the history.](https://oldvcr.blogspot.com/2024/02/cap-x-and-comp-x-how-tandy-pocket.html)

CAP-X/COMP-X has some unusual idiosyncrasies by modern standards
that nevertheless weren't unusual for contemporary CPUs, such as no direct
register-to-register moves, no comparison instructions, limited Boolean and
math instructions, nearly non-existent I/O, a strict assembler syntax, and
even an inability to directly access memory outside of the currently executing
page. It also had a small register file and no hardware stack, and most
implementations were limited to only a small addressing space. Since these
restrictions
might be encountered on other architectures, IT professionals of the era had
to know such sharp edges could be present and how to program around them.

However, these idiosyncrasies also make CAP-X/COMP-X a splendid modern
[esoteric programming language](https://esolangs.org/) and an unintentional
example of a Weird Instruction Set Computer. CRAP-X adds only minor features
to the runtime (enhanced I/O, bigger addressing space) and some syntactic
enhancements to the assembler. Those tweaks provide just enough power and
expressiveness to make it look like you can do practical things in it
until you actually try to. Now, *that*'s an esolang.

## What's in the box

CRAP-X is provided as a set of scripts written in cross-platform Perl 5. No
additional CPAN libraries are required. They should run anywhere Perl can.

* An assembler. This accepts CAP-X source, with or without CRAP-X enhancements, on standard input (or as a file argument) and emits a binary on standard output that contains platform-independent bytecode and a symbol table. It also includes modes for ensuring the source will also be acceptable to a real Tandy PC-5 or Tandy PC-6.

* A disassembler. This accepts a binary generated by the assembler on standard input (or as a file argument) and emits a disassembly on standard output, using symbols if present.

* A monitor. This accepts a binary generated by the assembler as a file argument and provides the runtime and debugger, with an experience similar to the Pocket Computers I first puzzled over the language with, as well as modes for ensuring execution will run the same or similarly on a real PC-5 or PC-6.

* [Multiple examples](examples), both for CRAP-X and original CAP-X/COMP-X (these will even run on a real Pocket Computer: I tested them by labouriously keying them in by hand).

## Test drive

Here are two unmodified sessions. The first is a CRAP-X
[hello world example](examples/hello.cap)
using CRAP-X's enhanced I/O, showing you the basic steps to assemble and run
CRAP-X or CAP-X/COMP-X programs. It is then followed by another CRAP-X
example that
[performs ROT-13](examples/rot13.cap) on data from standard input.

```
% perl asmbl.pl examples/hello.cap > hello.bin
% perl mon.pl hello.bin
hello world
% perl asmbl.pl examples/rot13.cap > rot13.bin
% echo 'hello world in rot13' | perl mon.pl rot13.bin
uryyb jbeyq va ebg13
% echo 'hello world in rot13' | perl mon.pl rot13.bin | perl mon.pl rot13.bin
hello world in rot13
%
```

This second one runs a simple classic CAP-X program to
[add two numbers](examples/classic/add.cap)
together, both straight up and in the debugger. The `123` and `456` were
entered by the operator in response to a prompt. This is
about as much of a "hello world" as you can
reasonably get in classic CAP-X/COMP-X.

```
% perl asmbl.pl examples/classic/add.cap > add.bin
% perl mon.pl add.bin
GR0 (10) 123
GR1 (10) 456
GR0 (10) 579 
% perl mon.pl -debug add.bin
256:Go/Dump/Symbols/^Cal or Trace (Off) t
Trace is On
256:Go/Dump/Symbols/^Cal or Trace (On) s
0000 GO
0006 TAD
256:Go/Dump/Symbols/^Cal or Trace (On) g
Go 0 
GR0 (10) 123
    0:500A 123 -6000 -25203 -15365 
GR1 (10) 456
    1:540A 123 456 -25203 -15365 
    2:D406 123 456 -25203 -15365 
    3:A006 579 456 -25203 -15365 
GR0 (10) 579 
    4:600A 579 456 -25203 -15365 
exiting with SC = 0000
256:Go/Dump/Symbols/^Cal or Trace (On) d
Dump:Object/Register r
BR : 0000 0
GR0: 0243 579
GR1: 01C8 456
GR2: 9D8D -25203
GR3: C3FB -15365
SC : 0000 0
CC : 0000 0
256:Go/Dump/Symbols/^Cal or Trace (On) d
Dump:Object/Register o
from 0
from 0 to 10
from 0 to 10
    0:500A READ 00   10
    1:540A READ 10   10
    2:D406 ST   10   6
    3:A006 ADD  00   6
    4:600A WRITE00   10
    5:0000 HJ   00   0
    6:01C8 HJ   01   200
    7:0000 HJ   00   0
    8:0000 HJ   00   0
    9:0000 HJ   00   0
   10:0000 HJ   00   0
256:Go/Dump/Symbols/^Cal or Trace (On) c
%
```

## A brief primer of the architecture

COMP-X is a 16-bit architecture using signed twos-complement math. Opcodes
are 16-bit and all access is by word (no byte). As such, the virtual machine
has no intrinsic endianness, though by convention the most significant bit
of a 16-bit word is numbered as zero. The maximum addressing space is 64
kilowords (i.e., 128K). Fatal exceptions are generated for signed integer
overflow or underflow, out of bounds memory accesses, and illegal instructions,
none of which can be trapped. Initial contents of memory and registers, as well
as interrupts and NMIs, are not officially defined or described.

### Registers

All registers are 16-bit except for CC.

* GR0, GR1, GR2, GR3: signed 16-bit general purpose registers. Only GR1-GR3 can serve as index registers.

* BR: base register. The least significant byte of BR is always zero. The most significant byte of this register is used as the most significant byte of all memory accesses, even instruction fetches. It can only be modified by the `JSR` instruction.

* SC: sequence counter (i.e., program counter). The address of the current instruction is the LSB of SC merged with the MSB of BR.

* CC: condition code. This is the sign bit of the result from the last `ADD` or `SUB` instruction.

These registers are defined in the spec but are not visible to the programmer.
They are nevertheless modeled in the runtime.

* IR: instruction register. Contains the current instruction word.

* OR: operand register. Contains the word fetched from memory as the current instruction's operand, if any.

### Instructions

All canonical instructions are 16-bit and consist of this basic form:

* opcode: bits 0-3. There are 16 possible opcodes, but only 14 are defined.

* GR field: bits 4-5. This specifies the GPR operand, though for some instructions, notably branches and I/O, this is used as a constant field.

* XR field: bits 6-7. This specifies the GPR indexing the address, through for some instructions this is used as a constant field or ignored. If the XR field is zero, the address is indexed by zero and not the contents of GR0. Indexing still uses BR for the MSB of the effective address (i.e., indexing wraps within the current page instead of crossing into adjacent ones).

* AD field: bits 8-15. This is the LSB of the address, though for some instructions, notably I/O, bitshifts and immediate loads, this is used as a constant field. It may be modified by the contents of the register referenced in the XR field.

### Opcodes

{X} = contents of X. LSB(X) = least significant byte of X. MSB(X) = most significant byte of X. GR[GR] = the contents of the GPR indexed by GR. GR[XR]/0 = the contents of the GPR indexed by XR, except if XR == 0, in which case zero.

opcode | summary | GR | XR | operation
---|---|---|---|---
`ADD` (0xA) | bitwise AND | destination | index | OR = {MSB(BR) \| LSB(AD+GR[XR]/0)}, GR[GR] += OR, CC = GR[GR] & 0x8000. Fault if integer overflow.
`AND` (0xE) | signed add | destination | index | OR = {MSB(BR) \| LSB(AD+GR[XR]/0)}, GR[GR] &= OR
`EOR` (0xF) | bitwise exclusive OR | destination | index | OR = {MSB(BR) \| LSB(AD+GR[XR]/0)}, GR[GR] ^= OR
`HJ` (0x0) | halt-and-jump | ignored | index | SC = LSB(AD+GR[XR]/0), cleanly terminate program
`JC` (0x2) | jump on condition | option | index | GR must == 0, 1, 2 or 3. if GR == 0: no-op. if GR == 1: if CC == 1, SC = MSB(BR) \| LSB(AD+GR[XR]/0). if GR == 2: if CC == 0, SC = MSB(BR) \| LSB(AD+GR[XR]/0). if GR == 3: SC = MSB(BR) \| LSB(AD+GR[XR]/0).
`JNZ` (0x1) | jump if not zero | source | index | if GR[GR] != 0, SC = MSB(BR) \| LSB(AD+GR[XR]/0).
`JSR` (0x3) | jump to subroutine | destination | index | GR[GR] = SC, OR = {MSB(BR) \| LSB(AD+GR[XR]/0)}, SC = OR, BR = OR & 0xFF00. Fault if the new BR is outside the maximum addressing range.
`LAI` (0x8) | load 8-bit immediate | destination | index | GR[GR] = LSB(AD+GR[XR]/0)
`LD` (0xC) | load from memory | destination | index | OR = {MSB(BR) \| LSB(AD+GR[XR]/0)}, GR[GR] = OR
`READ` (0x5) | read from I/O | destination | 0 | XR must == 0. If AD == 10, display prompt with destination register name and radix, and accept signed decimal value from keyboard and deposit in GR[GR]. Repeat if unacceptable input. If AD == 16, display prompt with destination register name and radix, and accept hexadecimal value from keyboard and deposit in GR[GR]. Repeat if unacceptable input. If AD == 0 (*CRAP-X only*), read single byte from standard input and deposit low 7 bits in GR[GR]; EOF terminates the program cleanly. If AD == 1 (*CRAP-X only*), accept signed decimal value from keyboard without displaying prompt and deposit in GR[GR]. Repeat if unacceptable input. All other AD values/radices are invalid.
`SFT` (0x4) | signed bitshift | destination | option | XR must == 0 or 1. If XR == 0, shift GR[GR] AD bits right, preserving the sign of the resulting value. If XR == 1, shift GR[GR] AD bits left, clearing the sign bit. AD may be greater than 16.
`ST` (0xD) | store to memory | source | index | {MSB(BR) \| LSB(AD+GR[XR]/0)} = GR[GR]
`SUB` (0xB) | signed subtract | destination | index | OR = {MSB(BR) \| LSB(AD+GR[XR]/0)}, GR[GR] -= OR, CC = GR[GR] & 0x8000. Fault if integer underflow.
`WRITE` (0x6) | write to I/O | source | 0 | XR must == 0. If AD == 10, display source register name, radix and signed decimal contents. If AD == 16, display source register name, radix and hexadecimal contents. If AD == 0 (*CRAP-X only*), emit low 7 bits of GR[GR] as an ASCII character to standard output. If AD == 1 (*CRAP-X only*) display signed decimal contents without other information. All other AD values/radices are invalid.

Opcodes 0x7 and 0x9 are illegal. Invalid encodings and illegal instructions fault.

### Assembler format

The CAP-X assembler format is line-oriented with fields delimited by colons.
Whitespace is ignored and not treated as salient. Lines consist of the general
format

```
LABEL:OPCODE:GR:AD:XR
```

CAP-X requires all caps, though the CRAP-X assembler will accept lowercase
letters and uppercase them for you. *CRAP-X only: Line comments may be
specified with `#` or `;`, which will run through the end of the current line.
Blank lines are ignored.*

In the original implementation and on the Tandy PC-5/6
labels may be up to three characters long, consisting of numbers and letters,
but must start with a letter and have no whitespace. (*CRAP-X only: Labels
may be any length, with the same restrictions and case insensitivity.*)
If a label is not specified for a line, the colon is still
required (i.e., the line has a null label, like `:LAI:0:10`).

Both XR and GR should be specified as decimal values between 0 and 3 inclusive,
with additional limitations in certain instructions. The XR field
is optional (and the terminal colon need not be specified if it is left out).
If it is not specified, it is rendered as 0.

The AD field may be an 8-bit unsigned decimal value or a label, but only the
LSB of the label is used.

### Assembler pseudo-ops

CAP-X defines five pseudo-opcodes. They consist of the general format

```
LABEL:PSEUDOOP:ARGUMENT
```

* `START`: Indicates the location in memory to begin assembly. You must have at least one `START`, and your source code must begin with a `START` pseudo-op, but you may have multiple. If they overlap, they will overwrite previously assembled instructions (*CRAP-X only: and cause an error*). The argument should be an unsigned 16-bit decimal number (*CRAP-X only: or hexadecimal starting with `$`*). Labels are not supported as an argument.

* `END`: Indicates the end of assembly. You must have at least one `END`, and your source code must end with a fully specified `END` and address, but you may have multiple. Only your final `END` should specify an address, which is treated as the starting address to begin execution. The argument should be an unsigned 16-bit decimal number (*CRAP-X only: or hexadecimal starting with `$`*). Labels are allowed as an argument.

* `RESV`: Inserts a block of null 16-bit words with the count given by the argument. You must specify a value of at least one. Labels are not supported as an argument.

* `CONST`: Inserts a 16-bit constant hexadecimal value provided as the argument. This value is always in hexadecimal. Labels are not supported as an argument (*CRAP-X only: except in CRAP-X*). *CRAP-X only: You may also provide a quoted string as an argument to `CONST` which will be inserted as 16-bit words corresponding to each byte of the string. A null terminator is not automatically added.*

* `ADCON`: Inserts a 16-bit reference to an address provided as the argument, which may be either an unsigned 16-bit decimal number (*CRAP-X only: or hexadecimal starting with `$`*) or a label. (*In CRAP-X, `CONST` and `ADCON` are synonyms and both take labels, except that `ADCON` takes a decimal value and `CONST` takes a hexadecimal one.*)

## Assembler

### Command line usage

The assembler accepts CRAP-X/CAP-X source on standard input and emits the binary
on standard output. You can also provide the source code as a filename. These
command line arguments are supported:

* `-v`, `-verbose`: Display code generation verbosely. By default, show only errors and warnings.

* `-pc5`, `-pc6`: Set options and maximum memory size most compatible with either the Tandy PC-5 or Tandy PC-6 Pocket Computers. This enforces most of their syntactic limitations so that you're less likely to write code that won't run on them. Normally all CRAP-X enhancements are enabled and the object can be a full 64 kilowords. In PC-5 mode, the object must be less than 512 words; in PC-6 mode, the object must be less than 2 kilowords. You may not specify both options at the same time.

* `-tlabels`: By default CRAP-X allows labels of unlimited length; this enforces the three character maximum. Set by `-pc5` and `-pc6`.

* `-comms`: Enable comments with `#` and `;`. On by default except with `-pc5` and `-pc6`.

* `-hexa`: Enable pseudo-ops to take hexadecimal arguments preceded by `$` (`CONST` is always in hex). On by default except with `-pc5` and `-pc6`.

### Binary format

The current binary emits big-endian shorts, as G-d intended. The first three words are the loading address, starting address and length of the code segment, followed by the complete stream of the code segment. An optional symbol table follows consisting of a 4-byte hexadecimal address, whitespace and the label, delimited by newlines.

## Disassembler

### Command line usage

The disassembler accepts a CRAP-X binary on standard input and emits 
disassembly on standard output. You can also provide the binary as a filename.
These command line arguments are supported:

* `-sym`: Only display the symbol table, if any, and then terminate.

## Monitor

### Command line usage

The monitor accepts a CRAP-X binary as a filename. By default execution
starts immediately at the provided starting address, and upon termination
(normal or otherwise) returns you to your shell. Programs are terminated
abnormally by integer overflow, out-of-bounds memory access or an
illegal instruction, and cleanly by the `HJ` instruction, *CRAP-X only:
EOF on standard input*, or CTRL-C or other break signals.

The execution environment is designed to mimic an enhanced PC-6. In original
CAP-X, `READ` instructions display a prompt displaying the destination
register and radix to which you enter (for radix 10) a signed 16-bit decimal
number or (for radix 16) a hexadecimal number. The program will pause and
repeatedly prompt until it receives acceptable input. `WRITE` instructions
will display the source register, radix and its contents as either signed
decimal or hexadecimal. If you have enabled strict PC-5 or PC-6 mode (see
below), these will pause until you press ENTER; you can enter the debugger
(see below) by typing D and pressing ENTER instead.

In enhanced CRAP-X, `READ` instructions with a radix of 0 fetch 7-bit
ASCII characters from standard input, terminating the program cleanly on
EOF, and a radix of 1 accepts a signed 16-bit decimal number like radix 10
but without displaying the standard prompt. `WRITE` instructions with a radix
of 0 write the low 7 bits of the register to standard output, and a radix of
1 displays the register as signed decimal without the other information.

These command line arguments are supported:

* `-pc5`, `-pc6`: Set options and maximum memory size most compatible with either the Tandy PC-5 or PC-6. By default all CRAP-X enhancements are enabled and the maximum addressing space is a full 64 kilowords. If either option is set, `READ` and `WRITE` radices other than 10 or 16 will generate an illegal instruction exception, execution pauses on `WRITE`, and the total size of the address space is limited to 512 words in PC-5 mode and 2 kilowords in PC-6 mode. You may not specify both options at the same time.

* `-debug`: Start execution in the debugger, displaying an enhanced form of the menu that appears after pressing the Asmbl button on the PC-5 or PC-6 (see below for operation). At termination or upon exception, you are returned to the debugger menu.

* `-trace`: Enable the debugger and automatically enable tracing mode, which displays each step in execution in the same way an actual PC-5/6 would, waiting for ENTER (or enter D for the debugger or T to turn off tracing, and press ENTER).

* `-supertrace`: Display all registers, including OR and IR, on every step. Does not pause, does not automatically enable the debugger.

### Debugger usage

The debugger displays a standard menu similar to the PC-5/6:

```
nnn:Go/Dump/Symbols/^Cal or Trace (On|Off)
```

where `nnn` is the number of allocated pages (PC-5, 2; PC-6, 8; 256 otherwise).
Options are selected by entering the letter and pressing ENTER.

* `G`: Go. The current value of SC, or the starting address, is provided by default. Press ENTER alone to accept it. You can enter a label or a new address which will change SC. Once accepted, press ENTER alone again to start execution.

* `D`: Dump. You will be prompted to dump either the Object (O, memory) or Registers (R, user-visible registers only). If you press R, then BR, GR0-3, SC and CC are shown. If you press D, you are prompted for the "from" and "to" addresses, which can be labels. Memory will be displayed along with the detected opcodes and GR, XR and AD fields as the PC-5/6 would disassemble them.

* `S`: Symbols. This replaces the Source option on a real PC-5/6. It displays the symbol table, if any.

* `C`: Cal. Like the PC-5/6, this returns you to your shell. You can also press CTRL-C.

* `T`: Trace. Toggles trace mode (on a PC-5/6, this would be MODE-2 and MODE-3).

When trace mode is on, each step in execution is displayed after the instruction
is retired. This consists of the SC (in decimal), the IR (in hex), and the
three GPRs in signed decimal. Execution advances a single instruction each
time by pressing ENTER alone. If
you type D and press ENTER, you will return to the debugger; if you type T and
press ENTER, tracing will be turned off.

## Don't submit pull requests or bug reports

... unless you intend to do the work. This is a toy and should be considered as such. It runs an obnoxiously wordy, cumbersome fictional assembly language that would seriously call into question your judgment and/or mental state to use it in a production environment. Bug reports without patches may or may not be addressed, ever. Feature requests without patches will be ignored and may be deleted outright.

Pull requests that refactor, port or substantially rewrite code will not be accepted unless you have a damn good reason (otherwise fork the project).

## License

Copyright (C) 2024 Cameron Kaiser. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE, SO THERE.
