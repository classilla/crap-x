#!/usr/bin/perl -s
#
# Runs a CRAP-X binary generated by the Asmbl script by providing a
# COMP-X VM and runtime environment with enhancements.
#
# Copyright (C) 2024 Cameron Kaiser.
# All rights reserved.
# BSD license.
# http://oldvcr.blogspot.com/
#
# Options
# -debug or -d: use debugger instead of autorunning and autoexiting
$d ||= 0;
$debug ||= $d;
# -supertrace: dumps complete VM status on every instruction
# runs independently of debug tracing mode, which is stepwise
$supertrace ||= 0;
# -trace: trace mode by default, implies -debug
$trace ||= 0;
$debug = 1 if ($trace);
# -pc5: limit to two pages, disable "zero radix" for ASCII READ/WRITE, pause
# on WRITE
$pc5 ||= 0;
# -pc6: limit to eight pages, disable "zero radix" for ASCII READ/WRITE, pause
# on WRITE
$pc6 ||= 0;
die("specify only one of -pc5 or -pc6\n") if ($pc5 && $pc6);
$maxaddr = 256 * (($pc5) ? 2 : ($pc6) ? 8 : 256);
$spad = " " x length("$maxaddr");

die("usage: $0 binary\n") if (!length($ARGV[0]));

$ov = $/;
$/ = \6;
($la, $sa, $len) = unpack("nnn", <ARGV>);

# validate this fits into the memory model
die <<"EOF" if ($sa >= $maxaddr || (($la + $len) >= $maxaddr));
can't execute in this memory model:
starts at $sa, loads at $la and $len words long, but the maximum supported
address for this configuration is $maxaddr
EOF

read(ARGV, $buf, $len + $len); # words, not bytes
$/ = $ov; # so that STDIN works again

die("no bytecode?\n") if (!length($buf));

# compute number of pages
$pages = ($maxaddr / 256);

# reconstruct and relocate in memory
@mem = unpack("n*", $buf);
if ($la) { unshift(@mem, 0) while ($la--); }

# read symbol table
while(<ARGV>) {
	chomp;
	@w = split(/\s+/, $_, 2);
	$labels{hex($w[0])} = $w[1];
	$rlabels{$w[1]} = hex($w[0]);
}

# defaults
$reg_cc = 0;
$reg_sc = $sa;
$reg_br = $sa & 65280;
$reg_ir = $mem[$sa];
$reg_or = $mem[$sa];
# emulate random contents
# since Perl math is natively unsigned, canonical form is unsigned,
# and we'll convert to and from signed when math needs doing
$reg_gr[0] = int(rand(65536));
$reg_gr[1] = int(rand(65536));
$reg_gr[2] = int(rand(65536));
$reg_gr[3] = int(rand(65536));

format STDERR =
@<<< @<<< - @<<< @<<< @<<< @<<< - @<<< @<<< @
sprintf("%04X", $reg_sc), sprintf("%04X", $reg_ir), sprintf("%04X", $reg_gr[0]), sprintf("%04X", $reg_gr[1]), sprintf("%04X", $reg_gr[2]), sprintf("%04X", $reg_gr[3]), sprintf("%04X", $reg_br), sprintf("%04X", $reg_or), $reg_cc
.
# as the PC-5/6 displays them
@ops = qw(HJ JNZ JC JSR SFT READ WRITE ***** LAI ***** ADD SUB LD ST AND EOR);

select(STDOUT); $|++;

# initial menu
MON: &debug if ($debug);

# run CPU
sub getea {
	my $xr = shift;
	my $ea = $ad;

	$ea += $reg_gr[$xr] if ($xr);
	$ea = $reg_br | ($ea & 255);
	return $ea;
}
sub sign { my $w = shift; return ($w & 32768) ? ($w - 65536) : $w; }
sub getor { $reg_or = $mem[&getea(@_)]; }
sub setcc { $reg_cc = shift; $reg_cc = ($reg_cc & 32768) >> 15; }
sub unsign { my $w = shift; return ($w < 0) ? ($w + 65536) : $w; }
CPU: for(;;) {
	$reg_ir = $mem[$reg_sc];
	$op = $reg_ir >> 12;
	$gr = ($reg_ir >> 10) & 3;
	$xr = ($reg_ir >> 8) & 3;
	$ad = ($reg_ir & 255);

	write STDERR if ($supertrace);
	# regular trace runs at the end of instruction dispatch

	# the spec in the Casio manual says we pre-increment SC
	# before executing the instruction in IR
	$old_sc = $reg_sc;
	$reg_sc++;
	$reg_sc = ($reg_br | ($reg_sc & 255));

	# ops done roughly in specification order
	if ($op == 0) {
		# HJ
		$reg_sc = $reg_br | $ad;
		if ($debug) {
			printf "exiting with SC = %04X\n", $reg_sc;
			goto MON;
		} else {
			$? = $reg_sc;
			last CPU;
		}
	} elsif ($op == 10) {
		# ADD, sets condition code
		# this math is signed. over/underflow throws exception.
		&getor($xr);
		$rv = &sign($reg_gr[$gr]) + &sign($reg_or);
		&ovf if ($rv < -32768 || $rv > 32767);
		$reg_gr[$gr] = &unsign($rv);
		&setcc($reg_gr[$gr]);
	} elsif ($op == 11) {
		# SUB, sets condition code
		# this math is signed. over/underflow throws exception.
		&getor($xr);
		$rv = &sign($reg_gr[$gr]) - &sign($reg_or);
		&ovf if ($rv < -32768 || $rv > 32767);
		$reg_gr[$gr] = &unsign($rv);
		&setcc($reg_gr[$gr]);
	} elsif ($op == 4) {
		# SFT, signed integers
		&ill if ($xr == 2 || $xr == 3);

		my $ob = $reg_gr[$gr] & 32768;
		if (!$ob) {
			# positive integers have a fast path
			if ($xr) {
				# left shift
				$reg_gr[$gr] = (($reg_gr[$gr] << $ad) & 32767);
			} else {
				# right shift
				$reg_gr[$gr] = $reg_gr[$gr] >> $ad;
			}
		} else {
			if ($xr) {
				# left shift
				$reg_gr[$gr] = $ob |
					(($reg_gr[$gr] << $ad) & 32767);
			} else {
				# right shift: build a bit string
				# 'use integer' would probably be better ...
				my $lead = (($ob) ? '1' : '0') x $ad;
				# ENDIAN!!!
				$reg_gr[$gr] = unpack("n", pack("B16",
				substr($lead . sprintf("%016b", $reg_gr[$gr]),
					0, 16)));
			}
		}
	} elsif ($op == 14) {
		# AND
		&getor($xr);
		$reg_gr[$gr] &= $reg_or;
	} elsif ($op == 15) {
		# EOR
		&getor($xr);
		$reg_gr[$gr] ^= $reg_or;
	} elsif ($op == 12) {
		# LD
		&getor($xr);
		$reg_gr[$gr] = $reg_or;
	} elsif ($op == 13) {
		# ST
		$mem[&getea($xr)] = $reg_gr[$gr];
	} elsif ($op == 8) {
		# LAI
		$reg_gr[$gr] = ($xr) ? $reg_gr[$xr] : 0;
		$reg_gr[$gr] = ($reg_gr[$gr] + $ad) & 255;
	} elsif ($op == 1) {
		# JNZ
		if ($reg_gr[$gr] != 0) {
			$reg_sc = $ad;
			$reg_sc += $reg_gr[$xr] if ($xr);
			$reg_sc = ($reg_br | ($reg_sc & 255)); 
		}
	} elsif ($op == 2) {
		# JC
		if ($gr == 0) {
			# no-op
		} elsif ($gr == 1) {
			$reg_sc = &getea($xr) if ($reg_cc);
		} elsif ($gr == 2) {
			$reg_sc = &getea($xr) unless ($reg_cc);
		} else {
			$reg_sc = &getea($xr);
		}
	} elsif ($op == 3) {
		# JSR
		&getor($xr);

		# only JSR can segfault
		&oob if ($reg_or >= $maxaddr);

		$reg_gr[$gr] = $reg_sc;
		$reg_br = $reg_or & 65280;
		$reg_sc = $reg_or;
	} elsif ($op == 5) {
		# READ
		&ill if ($xr);
		$radix = $ad;
		if (!$pc5 && !$pc6 && !$radix) {
			# Unicode not yet ...
			read(STDIN, $buf, 1);
			if (!length($buf)) {
				# eof received
				if ($debug) {
					print "End of Data\n";
					goto MON;
				}
				$? = 0;
				last CPU;
			}
			$reg_gr[$gr] = unpack("C", $buf);
		} elsif ($radix == 10 || $radix == 16
				|| ($radix == 1 && !$pc5 && !$pc6)) {
			$ok = 0;
			REDOFROMSTART: while(!$ok) {
				print "GR${gr} ($radix) " unless ($radix == 1);
				chomp($input = uc(<STDIN>));
				next REDOFROMSTART if (!length($input));

				if ($radix == 10 || $radix == 1) {
					$w = $input;
					if (substr($input, 0, 1) eq '-') {
						$w = substr($input, 1);
					}
					next REDOFROMSTART if (
						$w =~ /[^0-9]/);
					$input += 0;
					next REDOFROMSTART if ($input < -32768
						|| $input > 32767);
				} else {
					next REDOFROMSTART if
						(length($input) > 4);
					next REDOFROMSTART if
						($input =~ /[^0-9A-F]/);
					$input = hex($input);
				}
				$ok = 1;
			}
			$reg_gr[$gr] = &unsign($input);
		} else {
			# real machine bugs out on other radices
			&ill;
		}
	} elsif ($op == 6) {
		# WRITE
		&ill if ($xr);
		$radix = $ad;
		if (!$pc5 && !$pc6 && !$radix) {
			# Unicode not yet ...
			print chr($reg_gr[$gr] & 127);
		} elsif ($radix == 1 && !$pc5 && !$pc6) {
			# convert to signed short
			print &sign($reg_gr[$gr]);
		} elsif ($radix == 10) {
			# convert to signed short
			print "GR${gr} ($radix) ".
				&sign($reg_gr[$gr]) . " ";
			if ($pc5 || $pc6) {
				chomp($x = uc(<STDIN>));
				goto MON if ($x eq 'D' || $x eq 'DEBUG');
			} else { print "\n"; }
		} elsif ($radix == 16) {
			printf "GR${gr} ($radix) %04X ",
				$reg_gr[$gr];
			if ($pc5 || $pc6) {
				chomp($x = uc(<STDIN>));
				goto MON if ($x eq 'D' || $x eq 'DEBUG');
			} else { print "\n"; }
		} else {
			&ill;
		}
	} else {
		&ill;
	}

	if ($trace) {
		printf "%s:%04X %d %d %d %d ",
			substr("${spad}${old_sc}", -length($spad)),
			$reg_ir,
			&sign($reg_gr[0]),
			&sign($reg_gr[1]),
			&sign($reg_gr[2]),
			&sign($reg_gr[3]);
		chomp($w = uc(<STDIN>));
		if (length($w)) {
			goto MON if ($w eq 'D');
			$trace ^= 1 if ($w eq 'T');
		}
	}
}
exit;

# debugging menu
# act like an enhanced PC-5/6

sub debug {
	D1: for(;;) {
		print "$pages:Go/Dump/Symbols/^Cal or Trace ";
		print (($trace) ? "(On) " : "(Off) ");
		chomp($x = uc(<STDIN>));
		$x = substr($x, 0, 1);
		next D1 if ($x !~ /^[GDSCTQ]/);

		if ($x eq 'C' || $x eq 'Q') {
			exit;
		} elsif ($x eq 'T') {
			$trace ^= 1;
			print ("Trace is " . (($trace) ? "On\n" : "Off\n"));
		} elsif ($x eq 'S') {
			foreach (sort { $a <=> $b } keys %labels) {
				printf "%04X %s\n", $_, $labels{$_};
			}
		} elsif ($x eq 'G') {
			$value = &vprom($reg_sc, "Go %d ");
			$reg_sc = $value;
			$reg_br = $value & 65280;
			return;
		} elsif ($x eq 'D') {
			D2: for(;;) {
				print "Dump:Object/Register ";
				chomp($x = uc(<STDIN>));
				next D1 if (!length($x));
				last D2 if ($x eq 'O' || $x eq 'R');
			}
			if ($x eq 'O') {
				$from = &vprom($reg_sc, "from ", 1);
				$to = &vprom($from, "from $from to ", 1);
				print "from $from to $to\n";
				for($i=$from;$i<($to+1);$i++) {
					my $w = $mem[$i];
					my $op = $w >> 12;
					my $gr = ($w >> 10) & 3;
					my $xr = ($w >> 8) & 3;
					my $ad = ($w & 255);

					printf "%s:%04X %-5s%d%d   %d\n",
					substr("${spad}${i}", -length($spad)),
						$w, $ops[$op], $gr, $xr, $ad;
				}
			} else {
				# BR GR0-3 SC CC
				printf
					"BR : %04X %d\n" .
					"GR0: %04X %d\n" .
					"GR1: %04X %d\n" .
					"GR2: %04X %d\n" .
					"GR3: %04X %d\n" .
					"SC : %04X %d\n" .
					"CC : %04X %d\n",
						$reg_br, $reg_br,
						$reg_gr[0], &sign($reg_gr[0]),
						$reg_gr[1], &sign($reg_gr[1]),
						$reg_gr[2], &sign($reg_gr[2]),
						$reg_gr[3], &sign($reg_gr[3]),
						$reg_sc, $reg_sc,
						$reg_cc, $reg_cc;
			}
		}
	}
}

sub vprom {
	my $value = shift;
	my $prom = shift;
	my $noloop = shift;
	VP: for(;;) {
		printf $prom, $value;
		chomp($x = uc(<STDIN>));
		if (!length($x)) {
			return $value;
		} elsif (defined $rlabels{$x}) {
			$value = $rlabels{$x};
			last VP if ($noloop);
		} elsif ($x =~ /^[0-9]+$/) {
			$nsa = 0+$x;
			if ($nsa >= $maxaddr) {
				print "Out of Address\n";
				next VP;
			}
			$value = $nsa;
			last VP if ($noloop);
		}
	}
	return $value if ($noloop);
	die("unreached\n");
}

sub exception {
	print shift . " : SC $old_sc\n";
	exit 255 unless ($debug);

	# the SC points to the next address on real hardware, don't run it back
	goto MON;
}
# as they appear on the PC-5/6
sub ill { &exception("Bad code"); }
sub ovf { &exception("Over flow"); }
# we provide the SC here even though the real machine doesn't
sub oob { &exception("Out of Address"); }
